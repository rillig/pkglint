// Code generated by goyacc -o shellyacc.go -v shellyacc.log -p shyy shell.y. DO NOT EDIT.

//line shell.y:2
package pkglint

import __yyfmt__ "fmt"

//line shell.y:2

//line shell.y:18
type shyySymType struct {
	yys             int
	IONum           int
	List            *MkShList
	AndOr           *MkShAndOr
	Pipeline        *MkShPipeline
	Command         *MkShCommand
	CompoundCommand *MkShCompoundCommand
	Separator       MkShSeparator
	Simple          *MkShSimpleCommand
	FuncDef         *MkShFunctionDefinition
	For             *MkShFor
	If              *MkShIf
	Case            *MkShCase
	CaseItem        *MkShCaseItem
	Loop            *MkShLoop
	Words           []*ShToken
	Word            *ShToken
	Redirections    []*MkShRedirection
	Redirection     *MkShRedirection
}

const tkWORD = 57346
const tkASSIGNMENT_WORD = 57347
const tkNEWLINE = 57348
const tkIO_NUMBER = 57349
const tkBACKGROUND = 57350
const tkPIPE = 57351
const tkSEMI = 57352
const tkAND = 57353
const tkOR = 57354
const tkSEMISEMI = 57355
const tkLT = 57356
const tkGT = 57357
const tkLTLT = 57358
const tkGTGT = 57359
const tkLTAND = 57360
const tkGTAND = 57361
const tkLTGT = 57362
const tkLTLTDASH = 57363
const tkGTPIPE = 57364
const tkIF = 57365
const tkTHEN = 57366
const tkELSE = 57367
const tkELIF = 57368
const tkFI = 57369
const tkDO = 57370
const tkDONE = 57371
const tkCASE = 57372
const tkESAC = 57373
const tkWHILE = 57374
const tkUNTIL = 57375
const tkFOR = 57376
const tkLPAREN = 57377
const tkRPAREN = 57378
const tkLBRACE = 57379
const tkRBRACE = 57380
const tkEXCLAM = 57381
const tkIN = 57382

var shyyToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"tkWORD",
	"tkASSIGNMENT_WORD",
	"tkNEWLINE",
	"tkIO_NUMBER",
	"tkBACKGROUND",
	"tkPIPE",
	"tkSEMI",
	"tkAND",
	"tkOR",
	"tkSEMISEMI",
	"tkLT",
	"tkGT",
	"tkLTLT",
	"tkGTGT",
	"tkLTAND",
	"tkGTAND",
	"tkLTGT",
	"tkLTLTDASH",
	"tkGTPIPE",
	"tkIF",
	"tkTHEN",
	"tkELSE",
	"tkELIF",
	"tkFI",
	"tkDO",
	"tkDONE",
	"tkCASE",
	"tkESAC",
	"tkWHILE",
	"tkUNTIL",
	"tkFOR",
	"tkLPAREN",
	"tkRPAREN",
	"tkLBRACE",
	"tkRBRACE",
	"tkEXCLAM",
	"tkIN",
}

var shyyStatenames = [...]string{}

const shyyEofCode = 1
const shyyErrCode = 2
const shyyInitialStackSize = 16

//line yacctab:1
var shyyExca = [...]int16{
	-1, 0,
	1, 3,
	-2, 94,
	-1, 1,
	1, -1,
	-2, 0,
	-1, 137,
	9, 48,
	36, 48,
	-2, 47,
	-1, 155,
	31, 94,
	-2, 24,
	-1, 163,
	31, 93,
	-2, 98,
	-1, 167,
	31, 44,
	-2, 97,
}

const shyyPrivate = 57344

const shyyLast = 345

var shyyAct = [...]uint8{
	4, 121, 7, 139, 3, 5, 135, 134, 48, 115,
	12, 14, 64, 49, 9, 102, 103, 111, 97, 8,
	98, 94, 84, 147, 153, 153, 125, 25, 110, 124,
	123, 122, 67, 68, 103, 140, 71, 72, 73, 124,
	123, 154, 57, 57, 60, 65, 101, 17, 26, 88,
	35, 158, 152, 89, 90, 91, 156, 37, 39, 44,
	41, 38, 40, 42, 45, 43, 31, 87, 86, 137,
	99, 100, 93, 30, 56, 32, 33, 29, 28, 157,
	27, 36, 11, 137, 92, 54, 92, 65, 34, 104,
	58, 10, 95, 52, 53, 108, 144, 6, 46, 50,
	138, 51, 107, 55, 105, 106, 112, 128, 113, 118,
	133, 6, 120, 117, 138, 109, 159, 75, 129, 130,
	114, 95, 151, 85, 74, 77, 127, 70, 141, 142,
	76, 126, 69, 59, 119, 136, 118, 148, 145, 146,
	117, 149, 150, 143, 116, 24, 23, 132, 131, 21,
	22, 155, 20, 15, 16, 13, 161, 164, 165, 160,
	47, 163, 166, 167, 162, 17, 26, 19, 35, 78,
	79, 80, 81, 82, 83, 37, 39, 44, 41, 38,
	40, 42, 45, 43, 31, 18, 2, 1, 0, 0,
	0, 30, 0, 32, 33, 29, 28, 0, 27, 0,
	11, 17, 26, 0, 35, 0, 0, 0, 0, 0,
	0, 37, 39, 44, 41, 38, 40, 42, 45, 43,
	31, 0, 0, 0, 0, 66, 0, 30, 35, 32,
	33, 29, 28, 0, 27, 37, 39, 44, 41, 38,
	40, 42, 45, 43, 0, 0, 0, 0, 31, 0,
	0, 0, 0, 0, 0, 30, 63, 32, 33, 29,
	28, 0, 27, 62, 61, 0, 35, 0, 0, 0,
	0, 0, 0, 37, 39, 44, 41, 38, 40, 42,
	45, 43, 96, 0, 0, 35, 0, 0, 0, 0,
	0, 0, 37, 39, 44, 41, 38, 40, 42, 45,
	43, 66, 0, 0, 35, 0, 0, 0, 0, 0,
	0, 37, 39, 44, 41, 38, 40, 42, 45, 43,
	35, 0, 0, 0, 0, 0, 0, 37, 39, 44,
	41, 38, 40, 42, 45, 43, 37, 39, 44, 41,
	38, 40, 42, 45, 43,
}

var shyyPact = [...]int16{
	105, -1000, -1000, -1000, 161, 92, -1000, 91, 82, -1000,
	76, 197, -1000, -1000, 313, 313, 259, 221, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 105, 105, 128,
	123, 105, 105, 105, -1000, 322, -1000, 121, 121, 121,
	121, 121, 121, 121, 119, 119, -1000, 161, 105, 92,
	-1000, -1000, 105, 105, 105, 76, 313, -1000, 313, 297,
	-1000, -1000, -1000, -15, 278, -1000, -1000, -20, -16, 105,
	105, 22, 6, 6, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 82, -1000, 161,
	161, 197, -1000, 278, 105, -1000, -1000, -1000, -1000, -12,
	-23, 105, -1000, 105, -1000, -1000, -1000, -1000, 225, -1000,
	130, 105, 4, -3, -1000, 6, 103, 105, 105, -1000,
	79, 8, -1000, 105, 105, -1000, -1000, 6, -1000, -1000,
	-1000, 65, -8, -1000, -1000, -1000, 105, -1000, 118, 16,
	-1000, 17, -1000, -1000, -1000, -1000, -1000, -1000, 43, 66,
	15, -1000, -1000, 112, 105, 91, 105, 105, -1000, -1000,
	14, -1000, 105, 92, -1000, -1000, -1000, -1000,
}

var shyyPgo = [...]uint8{
	0, 187, 186, 4, 185, 167, 2, 15, 19, 14,
	91, 10, 11, 160, 8, 9, 155, 154, 12, 153,
	152, 150, 1, 149, 148, 147, 7, 6, 146, 145,
	144, 135, 3, 130, 133, 22, 74, 27, 88, 81,
	0, 5,
}

var shyyR1 = [...]int8{
	0, 1, 2, 2, 8, 8, 8, 9, 9, 10,
	10, 11, 11, 11, 11, 11, 12, 12, 12, 12,
	12, 12, 12, 5, 3, 3, 6, 6, 20, 20,
	20, 30, 30, 23, 23, 23, 25, 25, 24, 24,
	31, 31, 27, 27, 27, 26, 26, 26, 32, 32,
	21, 21, 22, 22, 22, 28, 29, 19, 4, 7,
	16, 16, 16, 16, 16, 34, 17, 17, 17, 17,
	18, 18, 18, 18, 36, 36, 37, 37, 37, 37,
	38, 38, 38, 38, 38, 38, 38, 33, 39, 39,
	35, 41, 41, 40, 40, 14, 14, 13, 13, 15,
	15,
}

var shyyR2 = [...]int8{
	0, 1, 1, 0, 1, 4, 4, 1, 2, 1,
	4, 1, 1, 2, 1, 2, 1, 1, 1, 1,
	1, 1, 1, 3, 2, 3, 1, 3, 4, 6,
	7, 1, 2, 7, 7, 6, 1, 2, 1, 2,
	3, 2, 2, 4, 5, 4, 4, 1, 1, 3,
	6, 5, 4, 5, 2, 3, 3, 5, 3, 3,
	3, 2, 1, 2, 1, 1, 1, 1, 2, 2,
	1, 1, 2, 2, 1, 2, 1, 2, 1, 2,
	2, 2, 2, 2, 2, 2, 2, 1, 2, 2,
	1, 1, 2, 1, 0, 1, 1, 2, 1, 2,
	2,
}

var shyyChk = [...]int16{
	-1000, -1, -2, -3, -40, -41, 6, -6, -8, -9,
	-10, 39, -11, -16, -12, -19, -17, 4, -4, -5,
	-20, -23, -21, -28, -29, -37, 5, 37, 35, 34,
	30, 23, 32, 33, -38, 7, -39, 14, 18, 15,
	19, 17, 20, 22, 16, 21, 6, -13, -14, -41,
	8, 10, 11, 12, 9, -10, -36, -37, -36, -34,
	-37, 5, 4, 35, -18, -37, 4, -3, -3, 4,
	4, -3, -3, -3, -38, -39, -33, 4, -33, -33,
	-33, -33, -33, -33, -35, 4, -35, -8, -40, -40,
	-40, -40, -37, -18, 36, -37, 4, 38, 36, -40,
	-40, 24, -7, 28, -7, -9, -9, -11, -40, -7,
	40, 40, -3, -3, -12, -15, -30, 10, 6, 4,
	-40, -22, 27, 26, 25, 29, -7, -15, 4, -40,
	-40, -24, -25, 31, -26, -27, -31, 4, 35, -32,
	27, -3, -3, -7, 31, -27, -26, 31, -40, -3,
	-32, 4, 36, 9, 24, -6, 13, 13, 36, 4,
	-3, -40, -14, -41, -40, -40, -22, -40,
}

var shyyDef = [...]int8{
	-2, -2, 1, 2, 0, 93, 91, 24, 26, 4,
	7, 0, 9, 11, 12, 14, 62, 64, 16, 17,
	18, 19, 20, 21, 22, 66, 67, 94, 94, 0,
	0, 94, 94, 94, 76, 0, 78, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 92, 25, 94, 98,
	95, 96, 94, 94, 94, 8, 13, 74, 15, 61,
	68, 69, 65, 0, 63, 70, 71, 0, 0, 94,
	94, 0, 0, 0, 77, 79, 80, 87, 81, 82,
	83, 84, 85, 86, 88, 90, 89, 27, 97, 0,
	0, 0, 75, 60, 94, 72, 73, 58, 23, 0,
	0, 94, 55, 94, 56, 5, 6, 10, 0, 28,
	0, 94, 0, 0, 57, 0, 0, 94, 94, 31,
	0, 0, 51, 94, 94, 59, 29, 0, 32, 99,
	100, 0, 0, 35, 38, 36, 94, -2, 0, 0,
	50, 0, 54, 30, 33, 37, 39, 34, 42, 0,
	0, 48, 41, 0, 94, -2, 94, 94, 40, 49,
	52, 43, 94, -2, 45, 46, 53, -2,
}

var shyyTok1 = [...]int8{
	1,
}

var shyyTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40,
}

var shyyTok3 = [...]int8{
	0,
}

var shyyErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	shyyDebug        = 0
	shyyErrorVerbose = false
)

type shyyLexer interface {
	Lex(lval *shyySymType) int
	Error(s string)
}

type shyyParser interface {
	Parse(shyyLexer) int
	Lookahead() int
}

type shyyParserImpl struct {
	lval  shyySymType
	stack [shyyInitialStackSize]shyySymType
	char  int
}

func (p *shyyParserImpl) Lookahead() int {
	return p.char
}

func shyyNewParser() shyyParser {
	return &shyyParserImpl{}
}

const shyyFlag = -1000

func shyyTokname(c int) string {
	if c >= 1 && c-1 < len(shyyToknames) {
		if shyyToknames[c-1] != "" {
			return shyyToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func shyyStatname(s int) string {
	if s >= 0 && s < len(shyyStatenames) {
		if shyyStatenames[s] != "" {
			return shyyStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func shyyErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !shyyErrorVerbose {
		return "syntax error"
	}

	for _, e := range shyyErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + shyyTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(shyyPact[state])
	for tok := TOKSTART; tok-1 < len(shyyToknames); tok++ {
		if n := base + tok; n >= 0 && n < shyyLast && int(shyyChk[int(shyyAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if shyyDef[state] == -2 {
		i := 0
		for shyyExca[i] != -1 || int(shyyExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; shyyExca[i] >= 0; i += 2 {
			tok := int(shyyExca[i])
			if tok < TOKSTART || shyyExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if shyyExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += shyyTokname(tok)
	}
	return res
}

func shyylex1(lex shyyLexer, lval *shyySymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(shyyTok1[0])
		goto out
	}
	if char < len(shyyTok1) {
		token = int(shyyTok1[char])
		goto out
	}
	if char >= shyyPrivate {
		if char < shyyPrivate+len(shyyTok2) {
			token = int(shyyTok2[char-shyyPrivate])
			goto out
		}
	}
	for i := 0; i < len(shyyTok3); i += 2 {
		token = int(shyyTok3[i+0])
		if token == char {
			token = int(shyyTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(shyyTok2[1]) /* unknown char */
	}
	if shyyDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", shyyTokname(token), uint(char))
	}
	return char, token
}

func shyyParse(shyylex shyyLexer) int {
	return shyyNewParser().Parse(shyylex)
}

func (shyyrcvr *shyyParserImpl) Parse(shyylex shyyLexer) int {
	var shyyn int
	var shyyVAL shyySymType
	var shyyDollar []shyySymType
	_ = shyyDollar // silence set and not used
	shyyS := shyyrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	shyystate := 0
	shyyrcvr.char = -1
	shyytoken := -1 // shyyrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		shyystate = -1
		shyyrcvr.char = -1
		shyytoken = -1
	}()
	shyyp := -1
	goto shyystack

ret0:
	return 0

ret1:
	return 1

shyystack:
	/* put a state and value onto the stack */
	if shyyDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", shyyTokname(shyytoken), shyyStatname(shyystate))
	}

	shyyp++
	if shyyp >= len(shyyS) {
		nyys := make([]shyySymType, len(shyyS)*2)
		copy(nyys, shyyS)
		shyyS = nyys
	}
	shyyS[shyyp] = shyyVAL
	shyyS[shyyp].yys = shyystate

shyynewstate:
	shyyn = int(shyyPact[shyystate])
	if shyyn <= shyyFlag {
		goto shyydefault /* simple state */
	}
	if shyyrcvr.char < 0 {
		shyyrcvr.char, shyytoken = shyylex1(shyylex, &shyyrcvr.lval)
	}
	shyyn += shyytoken
	if shyyn < 0 || shyyn >= shyyLast {
		goto shyydefault
	}
	shyyn = int(shyyAct[shyyn])
	if int(shyyChk[shyyn]) == shyytoken { /* valid shift */
		shyyrcvr.char = -1
		shyytoken = -1
		shyyVAL = shyyrcvr.lval
		shyystate = shyyn
		if Errflag > 0 {
			Errflag--
		}
		goto shyystack
	}

shyydefault:
	/* default state action */
	shyyn = int(shyyDef[shyystate])
	if shyyn == -2 {
		if shyyrcvr.char < 0 {
			shyyrcvr.char, shyytoken = shyylex1(shyylex, &shyyrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if shyyExca[xi+0] == -1 && int(shyyExca[xi+1]) == shyystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			shyyn = int(shyyExca[xi+0])
			if shyyn < 0 || shyyn == shyytoken {
				break
			}
		}
		shyyn = int(shyyExca[xi+1])
		if shyyn < 0 {
			goto ret0
		}
	}
	if shyyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			shyylex.Error(shyyErrorMessage(shyystate, shyytoken))
			Nerrs++
			if shyyDebug >= 1 {
				__yyfmt__.Printf("%s", shyyStatname(shyystate))
				__yyfmt__.Printf(" saw %s\n", shyyTokname(shyytoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for shyyp >= 0 {
				shyyn = int(shyyPact[shyyS[shyyp].yys]) + shyyErrCode
				if shyyn >= 0 && shyyn < shyyLast {
					shyystate = int(shyyAct[shyyn]) /* simulate a shift of "error" */
					if int(shyyChk[shyystate]) == shyyErrCode {
						goto shyystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if shyyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", shyyS[shyyp].yys)
				}
				shyyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if shyyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", shyyTokname(shyytoken))
			}
			if shyytoken == shyyEofCode {
				goto ret1
			}
			shyyrcvr.char = -1
			shyytoken = -1
			goto shyynewstate /* try again in the same state */
		}
	}

	/* reduction by production shyyn */
	if shyyDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", shyyn, shyyStatname(shyystate))
	}

	shyynt := shyyn
	shyypt := shyyp
	_ = shyypt // guard against "declared and not used"

	shyyp -= int(shyyR2[shyyn])
	// shyyp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if shyyp+1 >= len(shyyS) {
		nyys := make([]shyySymType, len(shyyS)*2)
		copy(nyys, shyyS)
		shyyS = nyys
	}
	shyyVAL = shyyS[shyyp+1]

	/* consult goto table to find next state */
	shyyn = int(shyyR1[shyyn])
	shyyg := int(shyyPgo[shyyn])
	shyyj := shyyg + shyyS[shyyp].yys + 1

	if shyyj >= shyyLast {
		shyystate = int(shyyAct[shyyg])
	} else {
		shyystate = int(shyyAct[shyyj])
		if int(shyyChk[shyystate]) != -shyyn {
			shyystate = int(shyyAct[shyyg])
		}
	}
	// dummy call; replaced with literal code
	switch shyynt {

	case 1:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:59
		{
			shyylex.(*ShellLexer).result = shyyVAL.List
		}
	case 2:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:63
		{
			/* empty */
		}
	case 3:
		shyyDollar = shyyS[shyypt-0 : shyypt+1]
//line shell.y:66
		{
			shyyVAL.List = &MkShList{}
		}
	case 4:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:70
		{
			shyyVAL.AndOr = NewMkShAndOr(shyyDollar[1].Pipeline)
		}
	case 5:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:73
		{
			shyyVAL.AndOr.Add("&&", shyyDollar[4].Pipeline)
		}
	case 6:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:76
		{
			shyyVAL.AndOr.Add("||", shyyDollar[4].Pipeline)
		}
	case 7:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:80
		{
			/* empty */
		}
	case 8:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:83
		{
			shyyVAL.Pipeline = shyyDollar[2].Pipeline
			shyyVAL.Pipeline.Negated = true
		}
	case 9:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:88
		{
			shyyVAL.Pipeline = NewMkShPipeline(false, []*MkShCommand{shyyDollar[1].Command})
		}
	case 10:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:91
		{
			shyyVAL.Pipeline.Add(shyyDollar[4].Command)
		}
	case 11:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:95
		{
			shyyVAL.Command = &MkShCommand{Simple: shyyDollar[1].Simple}
		}
	case 12:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:98
		{
			shyyVAL.Command = &MkShCommand{Compound: shyyDollar[1].CompoundCommand}
		}
	case 13:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:101
		{
			shyyVAL.Command = &MkShCommand{Compound: shyyDollar[1].CompoundCommand, Redirects: shyyDollar[2].Redirections}
		}
	case 14:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:104
		{
			shyyVAL.Command = &MkShCommand{FuncDef: shyyDollar[1].FuncDef}
		}
	case 15:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:107
		{
			shyyVAL.Command = &MkShCommand{FuncDef: shyyDollar[1].FuncDef, Redirects: shyyDollar[2].Redirections}
		}
	case 16:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:111
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{Brace: shyyDollar[1].List}
		}
	case 17:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:114
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{Subshell: shyyDollar[1].List}
		}
	case 18:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:117
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{For: shyyDollar[1].For}
		}
	case 19:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:120
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{Case: shyyDollar[1].Case}
		}
	case 20:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:123
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{If: shyyDollar[1].If}
		}
	case 21:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:126
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{Loop: shyyDollar[1].Loop}
		}
	case 22:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:129
		{
			shyyVAL.CompoundCommand = &MkShCompoundCommand{Loop: shyyDollar[1].Loop}
		}
	case 23:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:133
		{
			shyyVAL.List = shyyDollar[2].List
		}
	case 24:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:137
		{
			shyyVAL.List = shyyDollar[2].List
		}
	case 25:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:140
		{
			shyyVAL.List = shyyDollar[2].List
			shyyVAL.List.AddSeparator(shyyDollar[3].Separator)
		}
	case 26:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:145
		{
			shyyVAL.List = NewMkShList()
			shyyVAL.List.AddAndOr(shyyDollar[1].AndOr)
		}
	case 27:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:149
		{
			shyyVAL.List.AddSeparator(shyyDollar[2].Separator)
			shyyVAL.List.AddAndOr(shyyDollar[3].AndOr)
		}
	case 28:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:154
		{
			args := NewShToken("\"$$@\"",
				&ShAtom{shtText, "\"", shqDquot, nil},
				&ShAtom{shtShExpr, "$$@", shqDquot, "@"},
				&ShAtom{shtText, "\"", shqPlain, nil})
			shyyVAL.For = &MkShFor{shyyDollar[2].Word.MkText, []*ShToken{args}, shyyDollar[4].List}
		}
	case 29:
		shyyDollar = shyyS[shyypt-6 : shyypt+1]
//line shell.y:161
		{
			shyyVAL.For = &MkShFor{shyyDollar[2].Word.MkText, nil, shyyDollar[6].List}
		}
	case 30:
		shyyDollar = shyyS[shyypt-7 : shyypt+1]
//line shell.y:164
		{
			shyyVAL.For = &MkShFor{shyyDollar[2].Word.MkText, shyyDollar[5].Words, shyyDollar[7].List}
		}
	case 31:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:168
		{
			shyyVAL.Words = append(shyyVAL.Words, shyyDollar[1].Word)
		}
	case 32:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:171
		{
			shyyVAL.Words = append(shyyVAL.Words, shyyDollar[2].Word)
		}
	case 33:
		shyyDollar = shyyS[shyypt-7 : shyypt+1]
//line shell.y:175
		{
			shyyVAL.Case = shyyDollar[6].Case
			shyyVAL.Case.Word = shyyDollar[2].Word
		}
	case 34:
		shyyDollar = shyyS[shyypt-7 : shyypt+1]
//line shell.y:179
		{
			shyyVAL.Case = shyyDollar[6].Case
			shyyVAL.Case.Word = shyyDollar[2].Word
		}
	case 35:
		shyyDollar = shyyS[shyypt-6 : shyypt+1]
//line shell.y:183
		{
			shyyVAL.Case = &MkShCase{shyyDollar[2].Word, nil}
		}
	case 36:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:187
		{
			shyyVAL.Case = &MkShCase{nil, nil}
			shyyVAL.Case.Cases = append(shyyVAL.Case.Cases, shyyDollar[1].CaseItem)
		}
	case 37:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:191
		{
			shyyVAL.Case.Cases = append(shyyVAL.Case.Cases, shyyDollar[2].CaseItem)
		}
	case 38:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:195
		{
			shyyVAL.Case = &MkShCase{nil, nil}
			shyyVAL.Case.Cases = append(shyyVAL.Case.Cases, shyyDollar[1].CaseItem)
		}
	case 39:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:199
		{
			shyyVAL.Case.Cases = append(shyyVAL.Case.Cases, shyyDollar[2].CaseItem)
		}
	case 40:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:203
		{
			shyyVAL.Words = shyyDollar[2].Words
		}
	case 41:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:206
		{
			/* empty */
		}
	case 42:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:210
		{
			shyyVAL.CaseItem = &MkShCaseItem{shyyDollar[1].Words, &MkShList{}, sepNone, nil}
		}
	case 43:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:213
		{
			shyyVAL.CaseItem = &MkShCaseItem{shyyDollar[1].Words, shyyDollar[3].List, sepNone, nil}
		}
	case 44:
		shyyDollar = shyyS[shyypt-5 : shyypt+1]
//line shell.y:216
		{
			shyyVAL.CaseItem = &MkShCaseItem{shyyDollar[1].Words, shyyDollar[3].List, shyyDollar[4].Separator, nil}
		}
	case 45:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:220
		{
			shyyVAL.CaseItem = &MkShCaseItem{shyyDollar[1].Words, &MkShList{}, sepNone, nil}
		}
	case 46:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:223
		{
			shyyVAL.CaseItem = &MkShCaseItem{shyyDollar[1].Words, shyyDollar[2].List, sepNone, nil}
		}
	case 47:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:226
		{
			// Special case for ${SKIP:@p@ ${p}) continue;; @}
			shyyVAL.CaseItem = &MkShCaseItem{Var: shyyDollar[1].Word}
		}
	case 48:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:231
		{
			shyyVAL.Words = nil
			shyyVAL.Words = append(shyyVAL.Words, shyyDollar[1].Word)
		}
	case 49:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:235
		{
			shyyVAL.Words = append(shyyVAL.Words, shyyDollar[3].Word)
		}
	case 50:
		shyyDollar = shyyS[shyypt-6 : shyypt+1]
//line shell.y:239
		{
			shyyVAL.If = shyyDollar[5].If
			shyyVAL.If.Prepend(shyyDollar[2].List, shyyDollar[4].List)
		}
	case 51:
		shyyDollar = shyyS[shyypt-5 : shyypt+1]
//line shell.y:243
		{
			shyyVAL.If = &MkShIf{}
			shyyVAL.If.Prepend(shyyDollar[2].List, shyyDollar[4].List)
		}
	case 52:
		shyyDollar = shyyS[shyypt-4 : shyypt+1]
//line shell.y:248
		{
			shyyVAL.If = &MkShIf{}
			shyyVAL.If.Prepend(shyyDollar[2].List, shyyDollar[4].List)
		}
	case 53:
		shyyDollar = shyyS[shyypt-5 : shyypt+1]
//line shell.y:252
		{
			shyyVAL.If = shyyDollar[5].If
			shyyVAL.If.Prepend(shyyDollar[2].List, shyyDollar[4].List)
		}
	case 54:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:256
		{
			shyyVAL.If = &MkShIf{nil, nil, shyyDollar[2].List}
		}
	case 55:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:260
		{
			shyyVAL.Loop = &MkShLoop{shyyDollar[2].List, shyyDollar[3].List, false}
		}
	case 56:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:263
		{
			shyyVAL.Loop = &MkShLoop{shyyDollar[2].List, shyyDollar[3].List, true}
		}
	case 57:
		shyyDollar = shyyS[shyypt-5 : shyypt+1]
//line shell.y:267
		{ /* Apply rule 9 */
			shyyVAL.FuncDef = &MkShFunctionDefinition{shyyDollar[1].Word.MkText, shyyDollar[5].CompoundCommand}
		}
	case 58:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:271
		{
			shyyVAL.List = shyyDollar[2].List
		}
	case 59:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:275
		{
			shyyVAL.List = shyyDollar[2].List
		}
	case 60:
		shyyDollar = shyyS[shyypt-3 : shyypt+1]
//line shell.y:279
		{
			shyyVAL.Simple.Name = shyyDollar[2].Word
			shyyVAL.Simple.Args = append(shyyVAL.Simple.Args, shyyDollar[3].Simple.Args...)
			shyyVAL.Simple.Redirections = append(shyyVAL.Simple.Redirections, shyyDollar[3].Simple.Redirections...)
		}
	case 61:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:284
		{
			shyyVAL.Simple.Name = shyyDollar[2].Word
		}
	case 62:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:287
		{
			/* empty */
		}
	case 63:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:290
		{
			shyyVAL.Simple = shyyDollar[2].Simple
			shyyVAL.Simple.Name = shyyDollar[1].Word
		}
	case 64:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:294
		{
			shyyVAL.Simple = &MkShSimpleCommand{Name: shyyDollar[1].Word}
		}
	case 65:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:298
		{ /* Apply rule 7b */
			/* empty */
		}
	case 66:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:302
		{
			shyyVAL.Simple = &MkShSimpleCommand{}
			shyyVAL.Simple.Redirections = append(shyyVAL.Simple.Redirections, shyyDollar[1].Redirection)
		}
	case 67:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:306
		{
			shyyVAL.Simple = &MkShSimpleCommand{}
			shyyVAL.Simple.Assignments = append(shyyVAL.Simple.Assignments, shyyDollar[1].Word)
		}
	case 68:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:310
		{
			shyyVAL.Simple.Redirections = append(shyyVAL.Simple.Redirections, shyyDollar[2].Redirection)
		}
	case 69:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:313
		{
			shyyVAL.Simple.Assignments = append(shyyVAL.Simple.Assignments, shyyDollar[2].Word)
		}
	case 70:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:317
		{
			shyyVAL.Simple = &MkShSimpleCommand{}
			shyyVAL.Simple.Redirections = append(shyyVAL.Simple.Redirections, shyyDollar[1].Redirection)
		}
	case 71:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:321
		{
			shyyVAL.Simple = &MkShSimpleCommand{}
			shyyVAL.Simple.Args = append(shyyVAL.Simple.Args, shyyDollar[1].Word)
		}
	case 72:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:325
		{
			shyyVAL.Simple.Redirections = append(shyyVAL.Simple.Redirections, shyyDollar[2].Redirection)
		}
	case 73:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:328
		{
			shyyVAL.Simple.Args = append(shyyVAL.Simple.Args, shyyDollar[2].Word)
		}
	case 74:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:332
		{
			shyyVAL.Redirections = nil
			shyyVAL.Redirections = append(shyyVAL.Redirections, shyyDollar[1].Redirection)
		}
	case 75:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:336
		{
			shyyVAL.Redirections = append(shyyVAL.Redirections, shyyDollar[2].Redirection)
		}
	case 76:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:340
		{
			/* empty */
		}
	case 77:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:343
		{
			shyyVAL.Redirection = shyyDollar[2].Redirection
			shyyVAL.Redirection.Fd = shyyDollar[1].IONum
		}
	case 78:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:348
		{
			/* empty */
		}
	case 79:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:351
		{
			shyyVAL.Redirection = shyyDollar[2].Redirection
			shyyVAL.Redirection.Fd = shyyDollar[1].IONum
		}
	case 80:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:356
		{
			shyyVAL.Redirection = &MkShRedirection{-1, "<", shyyDollar[2].Word}
		}
	case 81:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:359
		{
			shyyVAL.Redirection = &MkShRedirection{-1, "<&", shyyDollar[2].Word}
		}
	case 82:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:362
		{
			shyyVAL.Redirection = &MkShRedirection{-1, ">", shyyDollar[2].Word}
		}
	case 83:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:365
		{
			shyyVAL.Redirection = &MkShRedirection{-1, ">&", shyyDollar[2].Word}
		}
	case 84:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:368
		{
			shyyVAL.Redirection = &MkShRedirection{-1, ">>", shyyDollar[2].Word}
		}
	case 85:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:371
		{
			shyyVAL.Redirection = &MkShRedirection{-1, "<>", shyyDollar[2].Word}
		}
	case 86:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:374
		{
			shyyVAL.Redirection = &MkShRedirection{-1, ">|", shyyDollar[2].Word}
		}
	case 87:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:378
		{ /* Apply rule 2 */
			/* empty */
		}
	case 88:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:382
		{
			shyyVAL.Redirection = &MkShRedirection{-1, "<<", shyyDollar[2].Word}
		}
	case 89:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:385
		{
			shyyVAL.Redirection = &MkShRedirection{-1, "<<-", shyyDollar[2].Word}
		}
	case 90:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:389
		{ /* Apply rule 3 */
			/* empty */
		}
	case 91:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:393
		{
			/* empty */
		}
	case 92:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:396
		{
			/* empty */
		}
	case 93:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:400
		{
			/* empty */
		}
	case 94:
		shyyDollar = shyyS[shyypt-0 : shyypt+1]
//line shell.y:403
		{
			/* empty */
		}
	case 95:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:407
		{
			shyyVAL.Separator = sepBackground
		}
	case 96:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:410
		{
			shyyVAL.Separator = sepSemicolon
		}
	case 97:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:414
		{
			/* empty */
		}
	case 98:
		shyyDollar = shyyS[shyypt-1 : shyypt+1]
//line shell.y:417
		{
			shyyVAL.Separator = sepNewline
		}
	case 99:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:421
		{
			shyyVAL.Separator = sepSemicolon
		}
	case 100:
		shyyDollar = shyyS[shyypt-2 : shyypt+1]
//line shell.y:424
		{
			shyyVAL.Separator = sepNewline
		}
	}
	goto shyystack /* stack new state and value */
}
